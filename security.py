"""
security.py - QR-Secure AES-256 Encryption Module
Handles cryptographic operations for the visitor management system.

Default encryption: AES-256-GCM (authenticated encryption).
Legacy support: AES-256-CBC with PKCS7 padding for older payloads.
Key storage: .secret.key file alongside this script.
"""

import base64
import binascii
import os

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import unpad

KEY_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), ".secret.key")
KEY_SIZE = 32  # 256 bits

# New payload format: base64(GCM_MAGIC + nonce + tag + ciphertext)
GCM_MAGIC = b"GCM1"
GCM_NONCE_SIZE = 12
GCM_TAG_SIZE = 16

# Legacy payload format: base64(iv + ciphertext)
IV_SIZE = 16  # AES block size


def _harden_key_file_permissions() -> None:
    """Best-effort permission hardening for key file."""
    try:
        os.chmod(KEY_FILE, 0o600)
    except OSError:
        # On some platforms/filesystems this may not be supported.
        pass


def _read_key_file() -> bytes:
    with open(KEY_FILE, "rb") as f:
        key = f.read()

    if len(key) != KEY_SIZE:
        raise ValueError(f"Corrupted key file: expected {KEY_SIZE} bytes, got {len(key)}")

    _harden_key_file_permissions()
    return key


def _load_or_create_key() -> bytes:
    """
    Load AES-256 key from disk, or generate it on first run.

    Returns:
        32-byte key suitable for AES-256.
    """
    if os.path.exists(KEY_FILE):
        return _read_key_file()

    key = get_random_bytes(KEY_SIZE)
    try:
        fd = os.open(KEY_FILE, os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o600)
        with os.fdopen(fd, "wb") as f:
            f.write(key)
    except FileExistsError:
        # Another process created the key concurrently.
        return _read_key_file()

    _harden_key_file_permissions()
    return key


# Load once at import time so every call reuses the same key.
_KEY = _load_or_create_key()


def _decode_base64_strict(encoded_text: str) -> bytes:
    try:
        return base64.b64decode(encoded_text, validate=True)
    except (binascii.Error, ValueError, TypeError) as exc:
        raise ValueError("Malformed encrypted payload.") from exc


def is_gcm_payload(encoded_text: str) -> bool:
    """
    Return True when payload is in the current AES-GCM format.
    """
    if not isinstance(encoded_text, str) or not encoded_text:
        return False
    try:
        raw = _decode_base64_strict(encoded_text)
    except ValueError:
        return False
    return raw.startswith(GCM_MAGIC)


def encrypt_data(plain_text: str) -> str:
    """
    Encrypt plaintext with AES-256-GCM.

    Args:
        plain_text: The string to encrypt.

    Returns:
        Base64 payload containing GCM metadata and ciphertext.

    Raises:
        ValueError: If plain_text is empty or not a string.
    """
    if not isinstance(plain_text, str):
        raise ValueError("plain_text must be a string.")
    if not plain_text:
        raise ValueError("Cannot encrypt empty data.")

    nonce = get_random_bytes(GCM_NONCE_SIZE)
    cipher = AES.new(_KEY, AES.MODE_GCM, nonce=nonce, mac_len=GCM_TAG_SIZE)
    ciphertext, tag = cipher.encrypt_and_digest(plain_text.encode("utf-8"))

    payload = GCM_MAGIC + nonce + tag + ciphertext
    return base64.b64encode(payload).decode("ascii")


def _decrypt_gcm_payload(raw: bytes) -> str:
    min_len = len(GCM_MAGIC) + GCM_NONCE_SIZE + GCM_TAG_SIZE + 1
    if len(raw) < min_len:
        raise ValueError("Malformed encrypted payload.")

    offset = len(GCM_MAGIC)
    nonce = raw[offset : offset + GCM_NONCE_SIZE]
    offset += GCM_NONCE_SIZE
    tag = raw[offset : offset + GCM_TAG_SIZE]
    ciphertext = raw[offset + GCM_TAG_SIZE :]

    try:
        cipher = AES.new(_KEY, AES.MODE_GCM, nonce=nonce, mac_len=GCM_TAG_SIZE)
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        return plaintext.decode("utf-8")
    except (ValueError, UnicodeDecodeError) as exc:
        raise ValueError("Invalid or tampered ciphertext.") from exc


def _decrypt_legacy_cbc_payload(raw: bytes) -> str:
    if len(raw) <= IV_SIZE:
        raise ValueError("Malformed legacy ciphertext payload.")

    iv = raw[:IV_SIZE]
    ciphertext = raw[IV_SIZE:]
    if len(ciphertext) == 0 or len(ciphertext) % AES.block_size != 0:
        raise ValueError("Malformed legacy ciphertext payload.")

    try:
        cipher = AES.new(_KEY, AES.MODE_CBC, iv)
        decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)
        return decrypted.decode("utf-8")
    except (ValueError, UnicodeDecodeError) as exc:
        raise ValueError("Invalid or tampered ciphertext.") from exc


def decrypt_data(encoded_text: str) -> str:
    """
    Decrypt payload generated by encrypt_data() or legacy CBC payloads.

    Args:
        encoded_text: Base64 encrypted payload string.

    Returns:
        Original plaintext string.

    Raises:
        ValueError: If payload is empty, malformed, or fails authenticity checks.
    """
    if not isinstance(encoded_text, str):
        raise ValueError("encoded_text must be a string.")
    if not encoded_text:
        raise ValueError("Cannot decrypt empty data.")

    raw = _decode_base64_strict(encoded_text)
    if raw.startswith(GCM_MAGIC):
        return _decrypt_gcm_payload(raw)

    # Backward compatibility: base64(iv + ciphertext) payloads.
    return _decrypt_legacy_cbc_payload(raw)


if __name__ == "__main__":
    samples = ["9876543210", "Meeting with Director", "Parcel delivery for Room 301"]
    print("--- AES-256 GCM Self-Test ---")
    for text in samples:
        enc = encrypt_data(text)
        dec = decrypt_data(enc)
        status = "OK" if dec == text else "FAIL"
        print(f"  [{status}] '{text}'")
        print(f"       Encrypted -> {enc[:48]}...")
        print(f"       Decrypted -> {dec}")
    print("--- Done ---")
